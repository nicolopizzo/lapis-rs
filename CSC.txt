export RUST_MIN_STACK=20000000

cargo build
cargo run -- PARAMS
cargo test CRATE::SUBCRATE::TEST

cargo run -- examples/matita-light/matita_basics_logic.dk 
cargo test parser::tests::test_matita
cargo test checking::tests::test_hard

# no serialization
# un solo test alla volta (codice "non rientrante")
# il logging su file funziona solo con i test

================================
NormaForms = boolean + term option
================================

PARSING BUGS:
1) essere passato ai nomi non qualificati per variabili legate
   e per le metavariabili ha fissato bug ==> il meccanismo di
   unbinding o non funziona bene o non è invocato sempre

BIG BUG:
1) quando libero una variabile legata, questa da BVar deve diventare
   una Var per non essere clonata
2) deep_clone potrebbe non clonare binder "chiusi" rispetto alle
   variabili da clonare
3) cambiare tipo di dato var in: o ha il binder, o la sub, o è libera
   per il fatto che sia meta?

ASSUNZIONI:
1) lhs patterns are in whnf

1) definizioni = dichiarazioni + rewrite rule!
   parser.rs, line 404
2) per i Theorem il body non viene controllato!
   parser.rs, line 188
3) new_prod_unbound in lnode è sospetto
4) nome fuorviante: ridenominare size in arity (e farlo 0 based?)
5) nome fuorviante: ridenominare parent in parents
6) Type/Kind non hanno parents
7) check_context verifica solo le regole (e non le dichiarazioni)
   e in ordine sparso!
8) type_check caso lambda anonimo vs tipo ==> che succede quando
   alle variabili libere del tipo che verranno rilegate da dei pi?
9) Type non è un singleton (sembra impossibile da fare in Rust
   perchè gli Rc<LNode> non sono thread safe per internal mutability!)
10) manca occur check per metavariabili

LENTEZZA:
* in type inference di applicazione
 //CSC XXXXYYYY was the cause of slowness: ????   let body = weak_head(body, rules);
 Ok(Some(body.clone()))
* // CSC: inefficient, deep_clone repeated multiple times
  nella right to left dell'applicazione
* // CSC: inefficient, deep_clone repeated multiple times
  anche nella weak head della whd
* le regole di riscrittura finiscono per ricalolare la forma
  normale degli argomenti di un'applicazione tante volte ==>
  fare storing (es. usando uno stack) come fa LambdaPi

1) parser: ufficio complicazione cose semplici?
   - si usa un'unica mappa per costanti e variabili
   - la mappa viene aggiornata per aggiungere/togliere
     variabili in/out of scope
   - nel caso di telescopi, in parser.rs ogni volta
     vengono ritolte e poi rimesse tutte le variabili
